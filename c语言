
一、写一个宏MIN，返回较小的一个参数
#define MIN((A),(B)) ((A)<=(B)?=(A):(B))~~~~~~~~~~~~~~

三、const作用～～～～～～～～～～～～～～～～
7．关键字const是什么含意？我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年DanSaks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：EmbeddedSystems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？

const int a;

int const a;

const int *a;

int * const a;

int const * a const;

haha

前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：

1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）

2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。

3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

四、volatile作用～～～～～～～～～～
8. 关键字volatile有什么含意并给出三个不同的例子。

一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：

1). 并行设备的硬件寄存器（如：状态寄存器）

2). 一个中断服务子程序中会访问到的非自动变量(Non-automaticvariables)

3). 多线程应用中被几个任务共享的变量回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题

。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙

是不是直正懂得volatile完全的重要性。

1). 一个参数既可以是const还可以是volatile吗？解释为什么。

2). 一个指针可以是volatile吗？解释为什么。

3). 下面的函数有什么错误：

int square(volatile int *ptr)

{

return *ptr * *ptr;

}

下面是答案：

1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。

3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

int square(volatile int *ptr)

{

int a,b;

a = *ptr;

b = *ptr;

return a * b;

}

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr)

{

int a;

a = *ptr;

return a * a;

}


栈的空间是1M，char p[1024*1024]（最多这样定义）

五、位操作(要求有可移植性)
 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a的bit 3。在以上两个操作中，要保持其它位不变

#define BIT3 (0x01<<3)
int a;
void SetBit(void)
{
	a |= BIT3;
}
void ClrBit(void)
{
	a &=~BIT3;
}


七、关于interrupt函数（返回值、参数、关键之、效率）



1、关键字__interrupt
2、该函数不能有返回值，也不能有参数
3、该函数最好避免浮点运算，也尽量不加打印，为了最高的效率


void foo(void)
{
	unsigned int a = 6;
	int b = -10;
	(a+b>6) puts("a"):puts("b");
}
结果是：？


当无符号整数和有符号整数进行运算时，系统会把有符号转换成无符号，然后进行运算
该答案是"a"

九、以下代码是否有问题（需要考虑什么）
unsigned int a = 0;
unsigned int b = 0xFFFF;



注意：有点处理器字长并不是16位，所以这种写法不正确，用unsigned int b = ~0;更合适


8、 请简述用户空间的内存分配及各空间保存的数据类型

用户空间供为3G，分为：栈空间，堆空间，数据区，代码段
栈空间保存：局部变量，函数形参，自动变量。栈空间特点，先进后出，空间由系统管理；栈空间生命周期所在函数执行结束

后释放；栈空间保存的局部变量未初始化时，默认初始化为随机值。

堆空间：由malloc , calloc ,ralloc，这些好函数分配的控件位堆空间，堆空间特点：先进先出，由用户管理

数据区：又分为.bss段、.data段、常量区。其中.bss段保存的是未初始化的全局变量，当全局变量未初始化时，系统默认初始

化为0，常量区保存的是常量，里面保存的值不能被修改，只能做读操作。.data段是保存已经初始化的全局变量以及被static修饰的

变量(静态变量)。数据区的声明周期是整个程序执行完之后再释放。

代码段保存的是代码

14、c++中的struct和class有什么不同？

    c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct中可以。c++中struct和class的主要区别是在于默认的存取权限不同，struct默认为Public，而class默认为private。
	
	18、volatile、static、const
    volatile的作用是告知编译器，它修饰的变量随时都可能被改变，因此，编译后的程序每次在
    使用该变量的值时，都会从变量的地址中读取数据，而不是从寄存器中获取。用在以下情况：
    (a)、并行设备的硬件寄存器（如：状态寄存器）
    (b)、一个中断服务子程序中会访问到的非自动变量(也就是全局变量)
    (c)、多线程应用中被几个任务共享的变量。

    static:
    1、static修饰全局变量：被修饰的全局变量的作用域范围限定为本源文件，
        另外的源文件不能通过extern关键词来使用这个全局变量。
    2、static修饰局部变量：a)被修饰的局部变量只能被初始化一次。b)被修饰的局部
        变量的存储空间发生了改变，不再存储在栈中，而是存储在数据段中。
    3、static修饰函数：被修饰的函数作用域范围限定为本源文件，另外的源文件不能使用被修饰的函数

    const:被const修饰的变量为只读的变量。例如：
    a) const int a;// a是只读的，a不能重新被赋值
    b) int const a;// 同(b)
    c) int const *a //指针a指向的内容是只读的，不能通过*a = 10来赋值，但是指针a本身可以重新被赋值，例如 a = &b
    d) const int *a //同(c)
    e) int *const a //指针a本身是只读的，不能令a重新指向，例如 a = &b，但是指针a指向的内容可以通过*a = 10来赋值
    f) const int *const a //指针a和a指向的内容都是只读的，不能执行a=&b，*a=10操作
	
	7、请简述sizeof()，和strlen()的区别

sizeof，测量一个变量或数据类型所占的字节长度，统计字符串长度的时候加上'\0'，在编译阶段的时候就可以计算出长度

strlen，计算字符串长度，在统计字符串长度的时候不加上'\0'，在函数运行的时候才计算出长度。



12、数组和链表的区别？

【标准答案】数组：数据顺序存储，固定大小；

链表：数据可以随机存储，大小可动态改变

20、要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;

那么要是想让程序跳转到绝对地址是0x100000去执行
，应该怎么做？

【标准答案】*((void (*)( ))0x100000 ) ( );
首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
然后再调用它:
*((void (*)())0x100000)();

 
 27、关键字volatile有什么含意? 并给出三个不同的例
子。
【参考答案】一个定义为volatile的变量是说这变量可
能会被意想不到地改变，这样，编译器就不会去假设
这个变量的值了。精确地说就是，优化器在用到这个
变量时必须每次都小心地重新读取这个变量的值，而
不是使用保存在寄存器里的备份。下面是volatile变量
的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量
(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量

 33、堆栈溢出一般是由什么原因导致的？
 
【标准答案】没有回收垃圾资源。

 35、全局变量可不可以定义在可被多个.C 文件包含的

【标准答案】可以，在不同的C 文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。

堆和栈的区别？
堆一般手动分配，空间比较大；
栈一般系统分配，空间比较有限；

38、用宏定义写出swap（x，y），即交换两数。
#define swap(x,y) x=x+y;y=x-y;x=x-y;
【标准答案】
#define swap(x, y) (x)=(x)+(y);(y)=(x)–(y);(x)=(x)–(y);

 40、带参宏与带参函数的区别(至少说出5点)？
【标准答案】
                      带参宏                带参函数
处理时间             编译时                运行时
参数类型                 无                需定义
程序长度                变长                不变
占用存储空间           否                    是
运行时间           不占运行时间      调用和返回时占

 
43、已知一个数组tabl e ，用一个宏定义，求出数据的元素个数。
【标准答案】
#define NTBL(table) (sizeof(table)/sizeof(table[0]))

 
关于45-47 的参考文章
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量
。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方
式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变
量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态
的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作
用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文
件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只
能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储
方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的
作用域，限制了它的使用范围。
static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使
用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中
说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件
中说明，要使用这些函数的源文件要包含这个头文件。

 49、什么是预编译，何时需要预编译：
【标准答案】
１、总是使用不经常改动的大型代码体
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

51、对于一个频繁使用的短小函数,在C 语言中应用什么实现,在C++ 中应用什么实现?
【标准答案】c用宏定义，c++ 用inline

 54、在C++  程序中调用被C 编译器编译后的函数，为什么要加extern “C”？
【标准答案】C++ 语言支持函数重载，C 语言不支持函
数重载。函数被C++ 编译后在库中的名字与 C 语言的
不同。假设某个函数的原型为：void foo(int x, int y); 
该函数被C 编译器编译后在库中的名字为_foo ，而
C++ 编译器则会产生像_foo_int_int之类的名字。 C++
提供了C 连接交换指定符号extern“C”来解决名字匹配
问题。

76、编写strcpy 函数
已知strcpy 函数的原型是 char *strcpy(char *strDest, const char *strSrc);其中strDest是目的字符串，strSrc 是源字符串。
（1）不调用C++/C 的字符串库函数，请编写函数
strcpy 。
（2）strcpy 能把 strSrc 的内容复制到strDest，为什
么还要char *  类型的返回值？
：这个返回值相当于一个附加功能，有了这个值可以更加方便的对strDest操作，实现链式表达式



char *hd_strcpy(char *strDest,const char *strSrc)
{
	char *temp = strDest; //纯C环境，不能在下面定义
	if((strDest == NULL)||(strSrc == NULL))
		return NULL;
	if(strDest == strSrc)
		return strDest;

	while((*strDest++ = *strSrc++) != '\0');
	return temp;

}

77、写出二分查找的代码。
【参考答案】 int b inary_search(int* arr, int k ey, int n)
{
int low =  0;
int h igh = n - 1 ;
int m id;
while (low <= high)
{
mid = (high + low) / 2;
if (arr[mid] > k)
high = mid -1 ;
else if (arr[mid] < k)
low = mid + 1;
else
return mid;
}
return -1;
}

78、请编写一个C 函数，该函数给出一个字节中被置1  的位的个数。
 

【参考答案】
unsigned int T estAsOne0(char log) 
{ 
int i; 
unsigned int num=0, val; 
for(i=0; i<8; i++) 
{ 
va l =  log >>  i;  // 移位
val & = 0x01;  // 与1 相与
if(val) 
num++; 
} 
return num; 
} 

 

 

79、请编写一个C 函数，该函数将给定的一个字符串
转换成整数。
【参考答案】
int Invert(char* str) 
{ 
int num =0; 
while(*str!='\0') 
{ 
int d igital=*str-48; 
num=num*10+digital; 
str=str+1; 
} 
return num; 
} 

 

 

80、请编写一个C 函数，该函数将给定的一个整数转
换成字符串。
【参考答案】
void IntToCharChange(int num,  char* pval) 
{ 
char strval[100]; 
int i , j; 
int val0 = 0; 
int val1 = 0; 
val0 = num; 
for(i=0; i<100; i++) 
{ 
val1 = val0 % 10; //取余
val0 = val0 / 10; // 取整
strval[i] = val1 + 48;  // 数字—字符
if(val0 < 10) 
{ 
i++; 
strval[i] = val0 + 48; 
break; 
} 
} 
for(j=0; j<=i; j++)  // 倒置
pval[j] = strval[i-j]; 
pval[j] = '\0'; 
}

 

 

81、实现strcmp 函数。
【参考答案】
int m ystrcmp(const c har* str1, const char* str2)
{
assert((str1 != NULL) && (str2 != NULL));
int r et = 0;
while (!(ret = *(unsigned char*)str1 - * (unsigned char*)str2) && *str2)
{
str1++;
str2++;
}
if (ret > 0)
ret = 1;
else if (ret < 0)
ret = -1;
return ret;
}

 

 

82、请编写一个C 函数，该函数将一个字符串逆序。
【参考答案】
void AntitoneValue(cha r* father, char* child) 
{ 
int i ; 
char source[100]; 
int j = 0; 
while(father[j]) //放入source ，[j] 为长度
{ 
source[j] = father[j]; 
j++; 
if(j > 99) 
return; 
} 
source[j] = '\0'; 
for(i=0; i<j; i++) 
child[i] = source[j-i-1];  // 反序
child[i] = '\0'; 
} 

 

 

83、请编写一个C 函数，该函数在给定的内存区域搜
索给定的字符，并返回该字符所在位置索引值。
【参考答案】
int s earch(char* cpSource, intn , char ch)  // 起始地址，搜索长度，目标字符
{
int i;
for(i=0; i<n && *(cpSource+i) != ch; ++i);
return i;
}

 

 

84、请编写一个C 函数，该函数在一个字符串中找到
可能的最长的子字符串，该字符串是由同一字符组成
的。
【参考答案】
int C hildString(char*p)     // 自己写
{   
char *q =p;
int s tringlen=0, i=0,j=1,len=0,maxlen=1;   
while(*q!=’\0’)          //不能用strlen, 求得长度stringlen
{
Stringlen++;
q++;
}
while( i<  String len )    
{   
if(*(p+i)==*(p+j)& & j< St ri ngle n )   
{   
len++;                    // 统计子串长度
i++;
j++;   
}   
else   
{   
if(len>maxlen)           // 统计最大子串长度
{   
maxlen=len+1;   
len=0;
}  
else
len=0;
i++;
j++;
}   
}  
retu rn   ma xlen;    
}

 

 

85、华为面试题：怎么判断链表中是否有环？
【参考答案】答：用两个指针来遍历这个单向链表，第
一个指针p1，每次走一步；第二个指针p2，每次走两
步；当p2 指针追上p1的时候，就表明链表当中有环
路了。
int testLinkRing(Link *head)
{
Link *t1=head,*t2=head;
while( t1->next && t2->next)
{
t1 = t1->next;
if (NULL == (t2 = t2->next->next))
return 0; // 无环
if (t1 == t2)
return 1;
}
return 0;
}

 

 

86、有一浮点型数组A, 用C 语言写一函数实现对浮点
数组A进行降序排序,并输出结果,要求要以数组A 作为
函数的入口.( 建议用冒泡排序法)
【参考答案】
void BubbleSort(double a rr[], int n) 
{ 
int i，j ；
int e xchange = 1 ；// 交换标志
for(i=1;i<n;i++)
{ // 最多做n-1趟排序
exchange=0 ；// 本趟排序开始前，交换标志应为假
for(j=n-1;j>=i ；j--) //对当前无序区R[i..n]自下向上扫描
if(arr[j+1] > arr [ j])
{// 交换记录
arr[0]=arr[j+1]；//R[0]不是哨兵，仅做暂存单元
arr[j+1]=arr[j]；
arr[j]=arr[0]；
exchange=1 ；// 发生了交换，故将交换标志置为真
} 
if(!exchange) // 本趟排序未发生交换，提前终止算法
return ；
} //endfor(外循环) 
}

 

 

87、实现双向链表删除一个节点P，在节点P 后插入一
个节点，写出这两个函数。
【参考答案】
// 删除操作
Status ListDelete_DuL(DuLinkList &L,inti,Ele mType &e)
{
if(!(p=G e tElemP_DuL(L,i))) return ERROR;
e=p->data;
p->prior->next=p->next;
p->next->prior=p->pror;
free(p);
return OK;
}
// 插入操作
Status ListInsert_DuL(DuLinkList &L,inti,ElemType &e)
{
if(!(p=G e tElemP_DuL(L,i)))
return ERROR;
if(!(s=(DuLinkList)malloc(sizeof(DuLNode))))
return ERROR;
s->data=e;
s->pri or =p;
p-> next -> prior =s;
p->next=s;
s->next=p->next->next;
return OK;
}

 

 

88、把一个链表反向。
【参考答案】从第一个元素开始，ps指向他，将他（
ps）指向头节点(ps->next = head) ，将ps设为头节点
（head = ps; ）操作下一个元素（ps= pe->next;）等
于是依次将每个元素翻到原头节点前面。
void reverse(test* head)
{
test* pe = head;
test* ps = head->next;
while(ps)
{ 
pe->next = ps->next;
ps->next = head;
head = ps;
ps =  pe->next;
}
}

 

 

89、将二维数组行列元素互换，存到另一个数组中。
【参考答案】
#include <stdio.h>
main()
{   int a [2][3]={{1,2,3},{4,5,6}};
int b[3][2],i,j;
printf("array a :\n");
for(i=0;i<=1;i++)
{   for(j=0;j<=2;j++)
{   printf("%5d",a[i][j]);
b[j][i]=a[i][j];
}
printf("\n");
}    
printf("array b :\n");
for(i=0;i<=2;i++)
{   for(j=0;j<=1;j++)
printf("%5d",b[i][j]);
printf("\n");
}
}

 

 

90、输入一行字符，统计其中有多少个单词。
【参考答案】
#include <stdio.h>
main()
{   
char str i ng[81];
int i,num=0,word=0;
char c;
gets(string);
for(i=0;(c=string[i])!='\0';i++)
if(c==' ')  
word=0;
else if(word==0)
{   
word=1;  num++;   }
printf("There are %d word s in the line\n",num);
}

 

 

91、写一个内存拷贝函数,不用任何库函数.就是前些时
候本版讨论的那个问题。
【参考答案】
void* m e mcpy(void* pvTo, const void* pvFrom, size_t size)
{
assert((pvTo != NULL) && (pvFrom ! = NULL));
byte* pbTo= pvTo;
byte* pbFrom = pbFrom;
while (size-- >  0)
{
*pbTo++ = *pbFrom++;
}
return pvTo;
}

 

 

92、有1、2、3 、4个数字，能组成多少个互不相同且
无重复数字的三位数？都是多少？
【参考答案】
#inc lude  "stdio.h"
#include "conio.h"
main()
{
int i,j,k;
printf("\n");
for(i=1;i<5;i++) /* 以下为三重循环*/
for(j=1;j<5;j++)
for (k=1;k<5;k++)
{
if (i!=k&&i!=j&&j!=k) /* 确保i、j、k三位互不相同*/
pr intf("%d,%d,%d\n",i,j,k);
}
getch();
}

 

 

93、取一个整数a从右端开始的4～7位。
【参考答案】
main()
{
unsigned a,b,c,d;
scanf("%o",&a);
b=a>>4;
c=~(~0<<4);
d=b&c;
printf("%o\n%o\n",a,d);

}
 

 

94、打印出杨辉三角形（要求打印出10行如下图）。
【参考答案】
main()
{
int i,j;
int a [10][10];
printf("\n");
for(i=0;i<10;i++)
{
a[i][0]=1;
a[i][i]=1;
}
for(i=2;i<10;i++)
for(j=1;j<i;j++)
a[i][j]=a[i-1][j-1]+a[i-1][j];
for(i=0;i<10;i++)
{
for(j=0;j<=i;j++)
printf("%5d",a[i][j]);
printf("\n");
}
getch(); 
}

 

 

95、实现strcmp 函数。
100 条经典 C语言笔试题目
96、写一个函数，求一个字符串的长度，在main函数
中输入字符串，并输出其长度。
【参考答案】
main()
{
intlen;
char *s tr[20];
printf("please input a string:\n");
scanf("%s",str);
len=length(str);
printf("the s tring has %d characters.",len);
getch();
}
length(p)
char *p;
{
int n ;
n=0;
while(*p!='\0')
{
n++;
p++;
}
return n;
}

 

 

97、809*??=800*??+9*??+1  其中??代表的两位数
,8*?? 的结果为两位数，9*??的结果为3位数。求??代
表的两位数，及809*??后的结果。
【参考答案】output(long b,long i)
{
printf("\n%ld/%ld=809*%ld+%ld",b,i,i,b%i);
}
main()
{
long int a ,b,i;
a=809;
for(i=10;i<100;i++)
{
b=i*a+1;
if(b>=1000&&b<=10000&&8*i<100&&9*i>=100)
output(b,i);
}
getch();
}

 

 

98、某个公司采用公用电话传递数据，数据是四位的整数，在
传递过程中是加密的，加密规则如下：每位数字都加上5, 然后
用和除以10的余数代替该数字，再将第一位和第四位交换，第
二位和第三位交换。
【参考答案】
main()
{
int a ,i,aa[4],t;
scanf( " % d " ,&a) ;
aa[0]=a %10;
aa[1]=a %100/10;
aa[2]=a %1000/100;
aa[3]=a /1000;
for(i=0 ; i<=3 ;i++)
{
aa [i]+=5;
aa[i] %=10;
}
for(i=0;i<=3/2;i++)
{
t=aa[i];
aa[i]= aa[3- i];
aa[3- i]= t ;
}
for(i=3;i>=0;i--)
prin tf("% d ", a [i]);
getch();
}

 

 

99、计算字符串中子串出现的次数。
【参考答案】
main()
{
char str1[20],str2[20],*p1,*p2;
int sum=0;
printf("please input two strings\n");
scanf("%s%s",str1,str2);
p1=str1;p2=str2;
while(*p1!='\0')
{
if(*p1==*p2)
{
while(*p1==*p2&&*p2!='\0')
{
p1++;
p2++;
}
}
else
p1++;
if(*p2=='\0')
sum++;
p2=str2;
}
printf("%d",sum);
getch();
} 

 

 

100 、有两个磁盘文件A和B, 各存放一行字母，要求把
这两个文件中的信息合并（按字母顺序排列），输出
到一个新文件C 中。


















【参考答案】
100 条经典 C语言笔试题目
main()
{
FILE *fp;
in t i,j,n,ni;
char c[160],t,ch;
if((fp=fopen("A","r "))==NULL)
{
printf("file A cannot  be opened\n");exit(0);
}
printf("\nA contents are :\n");
for(i=0;(ch=fgetc(fp))!=EOF ; i++)
{
c[i]=ch;pu tchar(c[i]);
}
fclose(fp);
ni=i;
if((fp=fopen("B","r "))==NULL)
{
printf("file B cannot  be opened\n");exit(0);
}
printf("\nB contents are :\n");
for(i=0;(ch=fgetc(fp))!=EOF ; i++)
{
c[i]=ch;pu tchar(c[i]);
}
fclose(fp);
n=i;
for(i=0;i<n;i++)
for(j=i+1;j<n;j++)
if(c[i]>c[j]){t=c[i ];c[i]=c[j];c[j]=t;}
printf("\nC file is:\n");
fp =f open("C","w");
for(i=0;i<n;i++){putc(c[i ],fp);putchar(c[i]);}
fclose(fp);
getch();
}
























		 